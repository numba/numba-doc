<!DOCTYPE html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>8.2.1. NBEP 2: Extension points &mdash; Numba 0.44.0.dev0+270.ga35920c-py2.7-linux-x86_64.egg documentation</title>
    
    <link rel="stylesheet" href="../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/numba-docs.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.44.0.dev0+270.ga35920c-py2.7-linux-x86_64.egg',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="../_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-3.3.7/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-sphinx.js"></script>
    <link rel="top" title="Numba 0.44.0.dev0+270.ga35920c-py2.7-linux-x86_64.egg documentation" href="../index.html" />
    <link rel="up" title="8. Numba Enhancement Proposals" href="index.html" />
    <link rel="next" title="8.2.2. NBEP 3: JIT Classes" href="jit-classes.html" />
    <link rel="prev" title="8.1.1. NBEP 1: Changes in integer typing" href="integer-typing.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">

  </head>
  <body role="document">

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../index.html"><span><img src="../_static/numba_blue_icon_rgb.png"></span>
          Numba</a>
        <span class="navbar-text navbar-version pull-left"><b>0.44</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../user/index.html">1. User Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="../reference/index.html">2. Reference Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cuda/index.html">3. Numba for CUDA GPUs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cuda-reference/index.html">4. CUDA Python Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../roc/index.html">5. Numba for AMD ROC GPUs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../extending/index.html">6. Extending Numba</a></li>
<li class="toctree-l1"><a class="reference internal" href="../developer/index.html">7. Developer Manual</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">8. Numba Enhancement Proposals</a></li>
<li class="toctree-l1"><a class="reference internal" href="../glossary.html">9. Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../release-notes.html">10. Release Notes</a></li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"><ul>
<li><a class="reference internal" href="#">8.2.1. NBEP 2: Extension points</a><ul>
<li><a class="reference internal" href="#high-level-api">8.2.1.1. High-level API</a><ul>
<li><a class="reference internal" href="#proposed-changes">8.2.1.1.1. Proposed changes</a><ul>
<li><a class="reference internal" href="#dedicated-module">8.2.1.1.1.1. Dedicated module</a></li>
<li><a class="reference internal" href="#implementing-a-function">8.2.1.1.1.2. Implementing a function</a></li>
<li><a class="reference internal" href="#implementing-an-attribute">8.2.1.1.1.3. Implementing an attribute</a></li>
<li><a class="reference internal" href="#implementing-a-method">8.2.1.1.1.4. Implementing a method</a></li>
<li><a class="reference internal" href="#exposing-a-structure-member">8.2.1.1.1.5. Exposing a structure member</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#typing">8.2.1.2. Typing</a><ul>
<li><a class="reference internal" href="#numba-types">8.2.1.2.1. Numba types</a><ul>
<li><a class="reference internal" href="#id1">8.2.1.2.1.1. Proposed changes</a></li>
</ul>
</li>
<li><a class="reference internal" href="#type-inference-on-values">8.2.1.2.2. Type inference on values</a><ul>
<li><a class="reference internal" href="#id2">8.2.1.2.2.1. Proposed changes</a></li>
</ul>
</li>
<li><a class="reference internal" href="#fast-path-for-type-inference-on-function-arguments">8.2.1.2.3. Fast path for type inference on function arguments</a><ul>
<li><a class="reference internal" href="#id3">8.2.1.2.3.1. Proposed changes</a></li>
</ul>
</li>
<li><a class="reference internal" href="#type-inference-on-operations">8.2.1.2.4. Type inference on operations</a><ul>
<li><a class="reference internal" href="#id4">8.2.1.2.4.1. Proposed changes</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#code-generation">8.2.1.3. Code generation</a><ul>
<li><a class="reference internal" href="#concrete-representation-of-values-of-a-numba-type">8.2.1.3.1. Concrete representation of values of a Numba type</a><ul>
<li><a class="reference internal" href="#id5">8.2.1.3.1.1. Proposed changes</a></li>
</ul>
</li>
<li><a class="reference internal" href="#conversion-between-types">8.2.1.3.2. Conversion between types</a><ul>
<li><a class="reference internal" href="#id6">8.2.1.3.2.1. Proposed changes</a></li>
</ul>
</li>
<li><a class="reference internal" href="#implementation-of-an-operation">8.2.1.3.3. Implementation of an operation</a><ul>
<li><a class="reference internal" href="#id7">8.2.1.3.3.1. Proposed changes</a></li>
</ul>
</li>
<li><a class="reference internal" href="#conversion-from-to-python-objects">8.2.1.3.4. Conversion from / to Python objects</a><ul>
<li><a class="reference internal" href="#id8">8.2.1.3.4.1. Proposed changes</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</ul>
</li>
              
            
            
              
                
  <li>
    <a href="integer-typing.html" title="Previous Chapter: 8.1.1. NBEP 1: Changes in integer typing"><span class="glyphicon glyphicon-chevron-left visible-sm"></span><span class="hidden-sm hidden-tablet">&laquo; 8.1.1. NBEP 1: C...</span>
    </a>
  </li>
  <li>
    <a href="jit-classes.html" title="Next Chapter: 8.2.2. NBEP 3: JIT Classes"><span class="glyphicon glyphicon-chevron-right visible-sm"></span><span class="hidden-sm hidden-tablet">8.2.2. NBEP 3: J... &raquo;</span>
    </a>
  </li>
              
            
            
            
            
              <li class="hidden-sm">
<div id="sourcelink">
  <a href="../_sources/proposals/extension-points.txt"
     rel="nofollow">Source</a>
</div></li>
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="col-md-12 content">
      
  <div class="section" id="nbep-2-extension-points">
<h1>8.2.1. NBEP 2: Extension points<a class="headerlink" href="#nbep-2-extension-points" title="Permalink to this headline">¶</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Author:</th><td class="field-body">Antoine Pitrou</td>
</tr>
<tr class="field-even field"><th class="field-name">Date:</th><td class="field-body">July 2015</td>
</tr>
<tr class="field-odd field"><th class="field-name">Status:</th><td class="field-body">Draft</td>
</tr>
</tbody>
</table>
<p>Implementing new types or functions in Numba requires hooking into
various mechanisms along the compilation chain (and potentially
outside of it).  This document aims, first, at examining the
current ways of doing so and, second, at making proposals to make
extending easier.</p>
<p>If some of the proposals are implemented, we should first strive
to use and exercise them internally, before exposing the APIs to the
public.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This document doesn&#8217;t cover CUDA or any other non-CPU backend.</p>
</div>
<div class="section" id="high-level-api">
<h2>8.2.1.1. High-level API<a class="headerlink" href="#high-level-api" title="Permalink to this headline">¶</a></h2>
<p>There is currently no high-level API, making some use cases more
complicated than they should be.</p>
<div class="section" id="proposed-changes">
<h3>8.2.1.1.1. Proposed changes<a class="headerlink" href="#proposed-changes" title="Permalink to this headline">¶</a></h3>
<div class="section" id="dedicated-module">
<h4>8.2.1.1.1.1. Dedicated module<a class="headerlink" href="#dedicated-module" title="Permalink to this headline">¶</a></h4>
<p>We propose the addition of a <code class="docutils literal"><span class="pre">numba.extending</span></code> module exposing the main
APIs useful for extending Numba.</p>
</div>
<div class="section" id="implementing-a-function">
<h4>8.2.1.1.1.2. Implementing a function<a class="headerlink" href="#implementing-a-function" title="Permalink to this headline">¶</a></h4>
<p>We propose the addition of a <code class="docutils literal"><span class="pre">&#64;overload</span></code> decorator allowing the
implementation of a given function for use in <a class="reference internal" href="../glossary.html#term-nopython-mode"><span class="xref std std-term">nopython mode</span></a>.
The overloading function has the same formal signature as the implemented
function, and receives the actual argument types.  It should return a
Python function implementing the overloaded function for the given types.</p>
<p>The following example implements <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.where.html#numpy.where" title="(in NumPy v1.16)"><code class="xref py py-func docutils literal"><span class="pre">numpy.where()</span></code></a> with
this approach.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">numba</span> <span class="kn">import</span> <span class="n">types</span>
<span class="kn">from</span> <span class="nn">numba.extending</span> <span class="kn">import</span> <span class="n">overload</span>

<span class="nd">@overload</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">where</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Implement np.where().</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># Choose implementation based on argument types.</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">Array</span><span class="p">):</span>
        <span class="c"># Array where() =&gt; return an array of the same shape</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">ty</span><span class="o">.</span><span class="n">layout</span> <span class="o">==</span> <span class="s">&#39;C&#39;</span> <span class="k">for</span> <span class="n">ty</span> <span class="ow">in</span> <span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)):</span>
            <span class="k">def</span> <span class="nf">where_impl</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
                <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Fast implementation for C-contiguous arrays</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="n">shape</span> <span class="o">=</span> <span class="n">cond</span><span class="o">.</span><span class="n">shape</span>
                <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">shape</span> <span class="ow">or</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">shape</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;all inputs should have the same shape&quot;</span><span class="p">)</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="n">cf</span> <span class="o">=</span> <span class="n">cond</span><span class="o">.</span><span class="n">flat</span>
                <span class="n">xf</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">flat</span>
                <span class="n">yf</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">flat</span>
                <span class="n">rf</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">flat</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cond</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
                    <span class="n">rf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">xf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="n">cf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">else</span> <span class="n">yf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">return</span> <span class="n">res</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">where_impl</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
                <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Generic implementation for other arrays</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="n">shape</span> <span class="o">=</span> <span class="n">cond</span><span class="o">.</span><span class="n">shape</span>
                <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">shape</span> <span class="ow">or</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">shape</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;all inputs should have the same shape&quot;</span><span class="p">)</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ndenumerate</span><span class="p">(</span><span class="n">cond</span><span class="p">):</span>
                    <span class="n">res</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">if</span> <span class="n">c</span> <span class="k">else</span> <span class="n">y</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                <span class="k">return</span> <span class="n">res</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">where_impl</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Scalar where() =&gt; return a 0-dim array</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">scal</span> <span class="o">=</span> <span class="n">x</span> <span class="k">if</span> <span class="n">cond</span> <span class="k">else</span> <span class="n">y</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">scal</span><span class="p">,</span> <span class="n">scal</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">where_impl</span>
</pre></div>
</div>
<p>It is also possible to implement functions already known to Numba, to
support additional types.  The following example implements the
built-in function <a class="reference external" href="https://docs.python.org/3/library/functions.html#len" title="(in Python v3.7)"><code class="xref py py-func docutils literal"><span class="pre">len()</span></code></a> for tuples with this approach:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@overload</span><span class="p">(</span><span class="nb">len</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">tuple_len</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
   <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">BaseTuple</span><span class="p">):</span>
      <span class="c"># The tuple length is known at compile-time, so simply reify it</span>
      <span class="c"># as a constant.</span>
      <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
      <span class="k">def</span> <span class="nf">len_impl</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
         <span class="k">return</span> <span class="n">n</span>
      <span class="k">return</span> <span class="n">len_impl</span>
</pre></div>
</div>
</div>
<div class="section" id="implementing-an-attribute">
<h4>8.2.1.1.1.3. Implementing an attribute<a class="headerlink" href="#implementing-an-attribute" title="Permalink to this headline">¶</a></h4>
<p>We propose the addition of a <code class="docutils literal"><span class="pre">&#64;overload_attribute</span></code> decorator allowing
the implementation of an attribute getter for use in <a class="reference internal" href="../glossary.html#term-nopython-mode"><span class="xref std std-term">nopython mode</span></a>.</p>
<p>The following example implements the <code class="docutils literal"><span class="pre">.nbytes</span></code> attribute on Numpy arrays:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@overload_attribute</span><span class="p">(</span><span class="n">types</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="s">&#39;nbytes&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">array_nbytes</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
   <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
       <span class="k">return</span> <span class="n">arr</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="n">arr</span><span class="o">.</span><span class="n">itemsize</span>
   <span class="k">return</span> <span class="n">get</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The overload_attribute() signature allows for expansion to also define
setters and deleters, by letting the decorated function return a
<code class="docutils literal"><span class="pre">getter,</span> <span class="pre">setter,</span> <span class="pre">deleter</span></code> tuple instead of a single <code class="docutils literal"><span class="pre">getter</span></code>.</p>
</div>
</div>
<div class="section" id="implementing-a-method">
<h4>8.2.1.1.1.4. Implementing a method<a class="headerlink" href="#implementing-a-method" title="Permalink to this headline">¶</a></h4>
<p>We propose the addition of a <code class="docutils literal"><span class="pre">&#64;overload_method</span></code> decorator allowing the
implementation of an instance method for use in <a class="reference internal" href="../glossary.html#term-nopython-mode"><span class="xref std std-term">nopython mode</span></a>.</p>
<p>The following example implements the <code class="docutils literal"><span class="pre">.take()</span></code> method on Numpy arrays:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@overload_method</span><span class="p">(</span><span class="n">types</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="s">&#39;take&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">array_take</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
   <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">Array</span><span class="p">):</span>
       <span class="k">def</span> <span class="nf">take_impl</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
           <span class="n">n</span> <span class="o">=</span> <span class="n">indices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
           <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
           <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
               <span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
           <span class="k">return</span> <span class="n">res</span>
       <span class="k">return</span> <span class="n">take_impl</span>
</pre></div>
</div>
</div>
<div class="section" id="exposing-a-structure-member">
<h4>8.2.1.1.1.5. Exposing a structure member<a class="headerlink" href="#exposing-a-structure-member" title="Permalink to this headline">¶</a></h4>
<p>We propose the addition of a <code class="docutils literal"><span class="pre">make_attribute_wrapper()</span></code> function exposing
an internal field as a visible read-only attribute, for those types backed
by a <code class="docutils literal"><span class="pre">StructModel</span></code> data model.</p>
<p>For example, assuming <code class="docutils literal"><span class="pre">PdIndexType</span></code> is the Numba type of pandas indices,
here is how to expose the underlying Numpy array as a <code class="docutils literal"><span class="pre">._data</span></code> attribute:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@register_model</span><span class="p">(</span><span class="n">PdIndexType</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">PdIndexModel</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">StructModel</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dmm</span><span class="p">,</span> <span class="n">fe_type</span><span class="p">):</span>
        <span class="n">members</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="s">&#39;values&#39;</span><span class="p">,</span> <span class="n">fe_type</span><span class="o">.</span><span class="n">as_array</span><span class="p">),</span>
            <span class="p">]</span>
        <span class="n">models</span><span class="o">.</span><span class="n">StructModel</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dmm</span><span class="p">,</span> <span class="n">fe_type</span><span class="p">,</span> <span class="n">members</span><span class="p">)</span>

<span class="n">make_attribute_wrapper</span><span class="p">(</span><span class="n">PdIndexType</span><span class="p">,</span> <span class="s">&#39;values&#39;</span><span class="p">,</span> <span class="s">&#39;_data&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="typing">
<h2>8.2.1.2. Typing<a class="headerlink" href="#typing" title="Permalink to this headline">¶</a></h2>
<div class="section" id="numba-types">
<h3>8.2.1.2.1. Numba types<a class="headerlink" href="#numba-types" title="Permalink to this headline">¶</a></h3>
<p>Numba&#8217;s standard types are declared in <code class="xref py py-mod docutils literal"><span class="pre">numba.types</span></code>.  To declare
a new type, one subclasses the base <code class="xref py py-class docutils literal"><span class="pre">Type</span></code> class or one of its
existing abstract subclasses, and implements the required functionality.</p>
<div class="section" id="id1">
<h4>8.2.1.2.1.1. Proposed changes<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h4>
<p>No change required.</p>
</div>
</div>
<div class="section" id="type-inference-on-values">
<h3>8.2.1.2.2. Type inference on values<a class="headerlink" href="#type-inference-on-values" title="Permalink to this headline">¶</a></h3>
<p>Values of a new type need to be type-inferred if they can appear as
function arguments or constants.  The core machinery is in
<code class="xref py py-mod docutils literal"><span class="pre">numba.typing.typeof</span></code>.</p>
<p>In the common case where some Python class or classes map exclusively
to the new type, one can extend a generic function to dispatch on said
classes, e.g.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">numba.typing.typeof</span> <span class="kn">import</span> <span class="n">typeof_impl</span>

<span class="nd">@typeof_impl</span><span class="p">(</span><span class="n">MyClass</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_typeof_myclass</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
   <span class="k">if</span> <span class="s">&quot;some condition&quot;</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">MyType</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">typeof_impl</span></code> specialization must return a Numba type instance,
or None if the value failed typing.</p>
<p>(when one controls the class being type-inferred, an alternative
to <code class="docutils literal"><span class="pre">typeof_impl</span></code> is to define a <code class="docutils literal"><span class="pre">_numba_type_</span></code> property on the class)</p>
<p>In the rarer case where the new type can denote various Python classes
that are impossible to enumerate, one must insert a manual check in the
fallback implementation of the <code class="docutils literal"><span class="pre">typeof_impl</span></code> generic function.</p>
<div class="section" id="id2">
<h4>8.2.1.2.2.1. Proposed changes<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>Allow people to define a generic hook without monkeypatching the
fallback implementation.</p>
</div>
</div>
<div class="section" id="fast-path-for-type-inference-on-function-arguments">
<h3>8.2.1.2.3. Fast path for type inference on function arguments<a class="headerlink" href="#fast-path-for-type-inference-on-function-arguments" title="Permalink to this headline">¶</a></h3>
<p>Optionally, one may want to allow a new type to participate in the
fast type resolution (written in C code) to minimize function call
overhead when a JIT-compiled function is called with the new type.
One must then insert the required checks and implementation in
the <code class="docutils literal"><span class="pre">_typeof.c</span></code> file, presumably inside the <code class="docutils literal"><span class="pre">compute_fingerprint()</span></code>
function.</p>
<div class="section" id="id3">
<h4>8.2.1.2.3.1. Proposed changes<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>None.  Adding generic hooks to C code embedded in a C Python extension
is too delicate a change.</p>
</div>
</div>
<div class="section" id="type-inference-on-operations">
<h3>8.2.1.2.4. Type inference on operations<a class="headerlink" href="#type-inference-on-operations" title="Permalink to this headline">¶</a></h3>
<p>Values resulting from various operations (function calls, operators, etc.)
are typed using a set of helpers called &#8220;templates&#8221;.  One can define a
new template by subclass one of the existing base classes and implement
the desired inference mechanism.  The template is explicitly registered
with the type inference machinery using a decorator.</p>
<p>The <code class="xref py py-class docutils literal"><span class="pre">ConcreteTemplate</span></code> base class allows one to define inference as
a set of supported signatures for a given operation.  The following example
types the modulo operator:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@builtin</span>
<span class="k">class</span> <span class="nc">BinOpMod</span><span class="p">(</span><span class="n">ConcreteTemplate</span><span class="p">):</span>
    <span class="n">key</span> <span class="o">=</span> <span class="s">&quot;%&quot;</span>
    <span class="n">cases</span> <span class="o">=</span> <span class="p">[</span><span class="n">signature</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span>
             <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">types</span><span class="o">.</span><span class="n">signed_domain</span><span class="p">)]</span>
    <span class="n">cases</span> <span class="o">+=</span> <span class="p">[</span><span class="n">signature</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span>
              <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">types</span><span class="o">.</span><span class="n">unsigned_domain</span><span class="p">)]</span>
    <span class="n">cases</span> <span class="o">+=</span> <span class="p">[</span><span class="n">signature</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">types</span><span class="o">.</span><span class="n">real_domain</span><span class="p">)]</span>
</pre></div>
</div>
<p>(note that type <em>instances</em> are used in the signatures, severely
limiting the amount of genericity that can be expressed)</p>
<p>The <code class="xref py py-class docutils literal"><span class="pre">AbstractTemplate</span></code> base class allows to define inference
programmatically, giving it full flexibility.  Here is a simplistic
example of how tuple indexing (i.e. the <code class="docutils literal"><span class="pre">__getitem__</span></code> operator) can
be expressed:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@builtin</span>
<span class="k">class</span> <span class="nc">GetItemUniTuple</span><span class="p">(</span><span class="n">AbstractTemplate</span><span class="p">):</span>
    <span class="n">key</span> <span class="o">=</span> <span class="s">&quot;getitem&quot;</span>

    <span class="k">def</span> <span class="nf">generic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kws</span><span class="p">):</span>
        <span class="n">tup</span><span class="p">,</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">args</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tup</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">UniTuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">Integer</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">signature</span><span class="p">(</span><span class="n">tup</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">tup</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="xref py py-class docutils literal"><span class="pre">AttributeTemplate</span></code> base class allows to type the attributes
and methods of a given type.  Here is an example, typing the <code class="docutils literal"><span class="pre">.real</span></code>
and <code class="docutils literal"><span class="pre">.imag</span></code> attributes of complex numbers:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@builtin_attr</span>
<span class="k">class</span> <span class="nc">ComplexAttribute</span><span class="p">(</span><span class="n">AttributeTemplate</span><span class="p">):</span>
    <span class="n">key</span> <span class="o">=</span> <span class="n">types</span><span class="o">.</span><span class="n">Complex</span>

    <span class="k">def</span> <span class="nf">resolve_real</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ty</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ty</span><span class="o">.</span><span class="n">underlying_float</span>

    <span class="k">def</span> <span class="nf">resolve_imag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ty</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ty</span><span class="o">.</span><span class="n">underlying_float</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><code class="xref py py-class docutils literal"><span class="pre">AttributeTemplate</span></code> only works for getting attributes.  Setting
an attribute&#8217;s value is hardcoded in <code class="xref py py-mod docutils literal"><span class="pre">numba.typeinfer</span></code>.</p>
</div>
<p>The <code class="xref py py-class docutils literal"><span class="pre">CallableTemplate</span></code> base class offers an easier way to parse
flexible function signatures, by letting one define a callable that has
the same definition as the function being typed.  For example, here is how
one could hypothetically type Python&#8217;s <code class="docutils literal"><span class="pre">sorted</span></code> function if Numba supported
lists:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@builtin</span>
<span class="k">class</span> <span class="nc">Sorted</span><span class="p">(</span><span class="n">CallableTemplate</span><span class="p">):</span>
    <span class="n">key</span> <span class="o">=</span> <span class="nb">sorted</span>

    <span class="k">def</span> <span class="nf">generic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">typer</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">reverse</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">reverse</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">Boolean</span><span class="p">):</span>
                <span class="k">return</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">Callable</span><span class="p">):</span>
                <span class="k">return</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">Iterable</span><span class="p">):</span>
                <span class="k">return</span>
            <span class="k">return</span> <span class="n">types</span><span class="o">.</span><span class="n">List</span><span class="p">(</span><span class="n">iterable</span><span class="o">.</span><span class="n">iterator_type</span><span class="o">.</span><span class="n">yield_type</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">typer</span>
</pre></div>
</div>
<p>(note you can return just the function&#8217;s return type instead of the
full signature)</p>
<div class="section" id="id4">
<h4>8.2.1.2.4.1. Proposed changes<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<p>Naming of the various decorators is quite vague and confusing.  We propose
renaming <code class="docutils literal"><span class="pre">&#64;builtin</span></code> to <code class="docutils literal"><span class="pre">&#64;infer</span></code>, <code class="docutils literal"><span class="pre">&#64;builtin_attr</span></code> to <code class="docutils literal"><span class="pre">&#64;infer_getattr</span></code>
and <code class="docutils literal"><span class="pre">builtin_global</span></code> to <code class="docutils literal"><span class="pre">infer_global</span></code>.</p>
<p>The two-step declaration for global values is a bit verbose, we propose
simplifying it by allowing the use of <code class="docutils literal"><span class="pre">infer_global</span></code> as a decorator:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@infer_global</span><span class="p">(</span><span class="nb">len</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">Len</span><span class="p">(</span><span class="n">AbstractTemplate</span><span class="p">):</span>
    <span class="n">key</span> <span class="o">=</span> <span class="nb">len</span>

    <span class="k">def</span> <span class="nf">generic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kws</span><span class="p">):</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">kws</span>
        <span class="p">(</span><span class="n">val</span><span class="p">,)</span> <span class="o">=</span> <span class="n">args</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="p">(</span><span class="n">types</span><span class="o">.</span><span class="n">Buffer</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">BaseTuple</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">signature</span><span class="p">(</span><span class="n">types</span><span class="o">.</span><span class="n">intp</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
</pre></div>
</div>
<p>The class-based API can feel clumsy, we can add a functional API for
some of the template kinds:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@type_callable</span><span class="p">(</span><span class="nb">sorted</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">type_sorted</span><span class="p">(</span><span class="n">context</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">typer</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="c"># [same function as above]</span>

    <span class="k">return</span> <span class="n">typer</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="code-generation">
<h2>8.2.1.3. Code generation<a class="headerlink" href="#code-generation" title="Permalink to this headline">¶</a></h2>
<div class="section" id="concrete-representation-of-values-of-a-numba-type">
<h3>8.2.1.3.1. Concrete representation of values of a Numba type<a class="headerlink" href="#concrete-representation-of-values-of-a-numba-type" title="Permalink to this headline">¶</a></h3>
<p>Any concrete Numba type must be able to be represented in LLVM form
(for variable storage, argument passing, etc.).  One defines that
representation by implementing a datamodel class and registering it
with a decorator.  Datamodel classes for standard types are defined
in <code class="xref py py-mod docutils literal"><span class="pre">numba.datamodel.models</span></code>.</p>
<div class="section" id="id5">
<h4>8.2.1.3.1.1. Proposed changes<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h4>
<p>No change required.</p>
</div>
</div>
<div class="section" id="conversion-between-types">
<h3>8.2.1.3.2. Conversion between types<a class="headerlink" href="#conversion-between-types" title="Permalink to this headline">¶</a></h3>
<p>Implicit conversion between Numba types is currently implemented as a
monolithic sequence of choices and type checks in the
<code class="xref py py-meth docutils literal"><span class="pre">BaseContext.cast()</span></code> method.  To add a new implicit conversion, one
appends a type-specific check in that method.</p>
<p>Boolean evaluation is a special case of implicit conversion (the
destination type being <code class="xref py py-class docutils literal"><span class="pre">types.Boolean</span></code>).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Explicit conversion is seen as a regular operation, e.g. a constructor
call.</p>
</div>
<div class="section" id="id6">
<h4>8.2.1.3.2.1. Proposed changes<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h4>
<p>Add a generic function for implicit conversion, with multiple dispatch
based on the source and destination types.  Here is an example showing
how to write a float-to-integer conversion:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@lower_cast</span><span class="p">(</span><span class="n">types</span><span class="o">.</span><span class="n">Float</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">Integer</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">float_to_integer</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">builder</span><span class="p">,</span> <span class="n">fromty</span><span class="p">,</span> <span class="n">toty</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
    <span class="n">lty</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">get_value_type</span><span class="p">(</span><span class="n">toty</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">toty</span><span class="o">.</span><span class="n">signed</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">builder</span><span class="o">.</span><span class="n">fptosi</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">lty</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">builder</span><span class="o">.</span><span class="n">fptoui</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">lty</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="implementation-of-an-operation">
<h3>8.2.1.3.3. Implementation of an operation<a class="headerlink" href="#implementation-of-an-operation" title="Permalink to this headline">¶</a></h3>
<p>Other operations are implemented and registered using a set of generic
functions and decorators.  For example, here is how lookup for a the <code class="docutils literal"><span class="pre">.ndim</span></code>
attribute on Numpy arrays is implemented:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@builtin_attr</span>
<span class="nd">@impl_attribute</span><span class="p">(</span><span class="n">types</span><span class="o">.</span><span class="n">Kind</span><span class="p">(</span><span class="n">types</span><span class="o">.</span><span class="n">Array</span><span class="p">),</span> <span class="s">&quot;ndim&quot;</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">array_ndim</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">builder</span><span class="p">,</span> <span class="n">typ</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">context</span><span class="o">.</span><span class="n">get_constant</span><span class="p">(</span><span class="n">types</span><span class="o">.</span><span class="n">intp</span><span class="p">,</span> <span class="n">typ</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
</pre></div>
</div>
<p>And here is how calling <code class="docutils literal"><span class="pre">len()</span></code> on a tuple value is implemented:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@builtin</span>
<span class="nd">@implement</span><span class="p">(</span><span class="n">types</span><span class="o">.</span><span class="n">len_type</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">Kind</span><span class="p">(</span><span class="n">types</span><span class="o">.</span><span class="n">BaseTuple</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">tuple_len</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">builder</span><span class="p">,</span> <span class="n">sig</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
    <span class="n">tupty</span><span class="p">,</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">args</span>
    <span class="n">retty</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">return_type</span>
    <span class="k">return</span> <span class="n">context</span><span class="o">.</span><span class="n">get_constant</span><span class="p">(</span><span class="n">retty</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">tupty</span><span class="o">.</span><span class="n">types</span><span class="p">))</span>
</pre></div>
</div>
<div class="section" id="id7">
<h4>8.2.1.3.3.1. Proposed changes<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h4>
<p>Review and streamine the API.  Drop the requirement to write
<code class="docutils literal"><span class="pre">types.Kind(...)</span></code> explicitly.  Remove the separate <code class="docutils literal"><span class="pre">&#64;implement</span></code>
decorator and rename <code class="docutils literal"><span class="pre">&#64;builtin</span></code> to <code class="docutils literal"><span class="pre">&#64;lower_builtin</span></code>, <code class="docutils literal"><span class="pre">&#64;builtin_attr</span></code>
to <code class="docutils literal"><span class="pre">&#64;lower_getattr</span></code>, etc.</p>
<p>Add decorators to implement <code class="docutils literal"><span class="pre">setattr()</span></code> operations, named
<code class="docutils literal"><span class="pre">&#64;lower_setattr</span></code> and <code class="docutils literal"><span class="pre">&#64;lower_setattr_generic</span></code>.</p>
</div>
</div>
<div class="section" id="conversion-from-to-python-objects">
<h3>8.2.1.3.4. Conversion from / to Python objects<a class="headerlink" href="#conversion-from-to-python-objects" title="Permalink to this headline">¶</a></h3>
<p>Some types need to be converted from or to Python objects, if they can
be passed as function arguments or returned from a function.  The
corresponding boxing and unboxing operations are implemented using
a generic function.  The implementations for standard Numba types
are in <code class="xref py py-mod docutils literal"><span class="pre">numba.targets.boxing</span></code>.  For example, here is the boxing
implementation for a boolean value:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@box</span><span class="p">(</span><span class="n">types</span><span class="o">.</span><span class="n">Boolean</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">box_bool</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">typ</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
    <span class="n">longval</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">builder</span><span class="o">.</span><span class="n">zext</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">pyapi</span><span class="o">.</span><span class="n">long</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">c</span><span class="o">.</span><span class="n">pyapi</span><span class="o">.</span><span class="n">bool_from_long</span><span class="p">(</span><span class="n">longval</span><span class="p">)</span>
</pre></div>
</div>
<div class="section" id="id8">
<h4>8.2.1.3.4.1. Proposed changes<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h4>
<p>Change the implementation signature from <code class="docutils literal"><span class="pre">(c,</span> <span class="pre">typ,</span> <span class="pre">val)</span></code> to
<code class="docutils literal"><span class="pre">(typ,</span> <span class="pre">val,</span> <span class="pre">c)</span></code>, to match the one chosen for the <code class="docutils literal"><span class="pre">typeof_impl</span></code>
generic function.</p>
</div>
</div>
</div>
</div>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2012, Anaconda, Inc..<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.<br/>
    </p>
  </div>
</footer>
  </body>
</html>